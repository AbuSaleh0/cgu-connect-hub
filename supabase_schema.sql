-- Enable necessary extensions
create extension if not exists "uuid-ossp";

-- Create users table
create table public.users (
  id bigint generated by default as identity primary key,
  username text unique not null,
  email text unique not null,
  auth_id uuid unique, -- Linked to auth.users.id
  password text not null, -- Required for all users (OAuth users set during onboarding)
  avatar text,
  display_name text,
  bio text,
  semester text,
  department text,
  profile_setup_complete boolean default false,
  password_setup_complete boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create posts table
create table public.posts (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete cascade not null,
  image text not null,
  images text[] default array[]::text[],
  caption text,
  likes_count int default 0,
  comments_count int default 0,
  pinned boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create likes table
create table public.likes (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete cascade not null,
  post_id bigint references public.posts(id) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, post_id)
);

-- Create comments table
create table public.comments (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete cascade not null,
  post_id bigint references public.posts(id) on delete cascade not null,
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create notifications table
create table public.notifications (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete cascade not null,
  type text not null check (type in ('like', 'comment', 'follow')),
  from_user_id bigint references public.users(id) on delete cascade not null,
  post_id bigint references public.posts(id) on delete cascade,
  message text not null,
  read boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create follows table
create table public.follows (
  id bigint generated by default as identity primary key,
  follower_id bigint references public.users(id) on delete cascade not null,
  following_id bigint references public.users(id) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(follower_id, following_id)
);

-- Create conversations table
create table public.conversations (
  id bigint generated by default as identity primary key,
  participant1_id bigint references public.users(id) on delete cascade not null,
  participant2_id bigint references public.users(id) on delete cascade not null,
  last_message_id bigint, -- Circular reference, handled carefully or ignored in FK for simplicity
  last_message_at timestamp with time zone default timezone('utc'::text, now()) not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create messages table
create table public.messages (
  id bigint generated by default as identity primary key,
  conversation_id bigint references public.conversations(id) on delete cascade not null,
  sender_id bigint references public.users(id) on delete cascade not null,
  content text not null,
  message_type text default 'text' check (message_type in ('text', 'image', 'video')),
  media_url text,
  is_read boolean default false,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Create saved_posts table
create table public.saved_posts (
  id bigint generated by default as identity primary key,
  user_id bigint references public.users(id) on delete cascade not null,
  post_id bigint references public.posts(id) on delete cascade not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  unique(user_id, post_id)
);

-- Enable Row Level Security (RLS)
alter table public.users enable row level security;
alter table public.posts enable row level security;
alter table public.likes enable row level security;
alter table public.comments enable row level security;
alter table public.notifications enable row level security;
alter table public.follows enable row level security;
alter table public.conversations enable row level security;
alter table public.messages enable row level security;
alter table public.saved_posts enable row level security;

-- Create RLS Policies (PROPERLY SECURED)

-- Users table policies
create policy "Users are viewable by everyone" on public.users for select using (true);
create policy "Users can insert their own profile" on public.users for insert with check (auth.uid() = auth_id);
create policy "Users can update own profile" on public.users for update using (auth.uid() = auth_id);
create policy "Users can delete own profile" on public.users for delete using (auth.uid() = auth_id);

-- Posts table policies
create policy "Posts are viewable by everyone" on public.posts for select using (true);
create policy "Users can insert own posts" on public.posts for insert with check (
  exists (select 1 from public.users where id = user_id and auth_id = auth.uid())
);
create policy "Users can update own posts" on public.posts for update using (
  exists (select 1 from public.users where id = user_id and auth_id = auth.uid())
);
create policy "Users can delete own posts" on public.posts for delete using (
  exists (select 1 from public.users where id = user_id and auth_id = auth.uid())
);

-- Likes table policies
create policy "Likes are viewable by everyone" on public.likes for select using (true);
create policy "Users can insert own likes" on public.likes for insert with check (
  exists (select 1 from public.users where id = user_id and auth_id = auth.uid())
);
create policy "Users can delete own likes" on public.likes for delete using (
  exists (select 1 from public.users where id = user_id and auth_id = auth.uid())
);

-- Comments table policies
create policy "Comments are viewable by everyone" on public.comments for select using (true);
create policy "Users can insert own comments" on public.comments for insert with check (
  exists (select 1 from public.users where id = user_id and auth_id = auth.uid())
);
create policy "Users can update own comments" on public.comments for update using (
  exists (select 1 from public.users where id = user_id and auth_id = auth.uid())
);
create policy "Users can delete own comments" on public.comments for delete using (
  exists (select 1 from public.users where id = user_id and auth_id = auth.uid())
);

-- Notifications table policies
create policy "Users can view own notifications" on public.notifications for select using (
  exists (
    select 1 from public.users 
    where (id = notifications.user_id or id = notifications.from_user_id) 
    and (
      auth_id::text = auth.uid()::text 
      OR 
      email = (auth.jwt() ->> 'email')
    )
  )
);
create policy "System can insert notifications" on public.notifications for insert with check (true);
create policy "Users can update own notifications" on public.notifications for update using (
  exists (select 1 from public.users where id = user_id and email = auth.uid()::text)
);
create policy "Users can delete own notifications" on public.notifications for delete using (
  exists (
    select 1 from public.users 
    where (id = notifications.user_id or id = notifications.from_user_id) 
    and (
      auth_id::text = auth.uid()::text 
      OR 
      email = (auth.jwt() ->> 'email')
    )
  )
);

-- Follows table policies
create policy "Follows are viewable by everyone" on public.follows for select using (true);
create policy "Users can insert own follows" on public.follows for insert with check (
  exists (select 1 from public.users where id = follower_id and auth_id = auth.uid())
);
create policy "Users can delete own follows" on public.follows for delete using (
  exists (select 1 from public.users where id = follower_id and auth_id = auth.uid())
);

-- Conversations table policies
create policy "Users can view own conversations" on public.conversations for select using (
  exists (
    select 1 from public.users 
    where (id = participant1_id or id = participant2_id) 
    and auth_id = auth.uid()
  )
);
create policy "Users can create conversations" on public.conversations for insert with check (
  exists (select 1 from public.users where id = participant1_id and auth_id = auth.uid())
);
create policy "Users can update own conversations" on public.conversations for update using (
  exists (
    select 1 from public.users 
    where (id = participant1_id or id = participant2_id) 
    and auth_id = auth.uid()
  )
);

-- Messages table policies
create policy "Users can view messages in own conversations" on public.messages for select using (
  exists (
    select 1 from public.conversations c
    join public.users u on (u.id = c.participant1_id or u.id = c.participant2_id)
    where c.id = conversation_id and u.auth_id = auth.uid()
  )
);
create policy "Users can insert messages in own conversations" on public.messages for insert with check (
  exists (
    select 1 from public.conversations c
    join public.users u on (u.id = c.participant1_id or u.id = c.participant2_id)
    where c.id = conversation_id and u.auth_id = auth.uid()
  )
);
create policy "Users can update own messages" on public.messages for update using (
  exists (select 1 from public.users where id = sender_id and auth_id = auth.uid())
);
create policy "Users can delete own messages" on public.messages for delete using (
  exists (select 1 from public.users where id = sender_id and auth_id = auth.uid())
);

-- Saved posts table policies
create policy "Users can view own saved posts" on public.saved_posts for select using (
  exists (select 1 from public.users where id = user_id and auth_id = auth.uid())
);
create policy "Users can insert own saved posts" on public.saved_posts for insert with check (
  exists (select 1 from public.users where id = user_id and auth_id = auth.uid())
);
create policy "Users can delete own saved posts" on public.saved_posts for delete using (
  exists (select 1 from public.users where id = user_id and auth_id = auth.uid())
);
